# Encryption

Similar to other Exasol connectors, PyEXASOL is capable of using TLS cryptographic protocol.

Exasol published a few articles describing the details:
- [Using TLS with our analytics database (part 1): understanding the basics](https://www.exasol.com/resource/using-tls-with-our-analytics-database-understanding-the-basics/);
- [Using TLS with our analytics database (part 2): secure communication with Exasol](https://www.exasol.com/resource/using-tls-with-our-analytics-database-secure-communication-with-exasol/)
- [TLS for all Exasol drivers](https://www.exasol.com/support/browse/EXASOL-2936)

### Defaults

PyEXASOL defaults are different compared to JDBC / ODBC drivers.

Encryption is disabled by default for connections with username and password. Encryption is enabled by default for connections with username and OpenID token.

The main reasons behind this decision are following:

- The main focus of PyEXASOL is performance. TLS encryption adds some overhead, which is often unnecessary.
- Exasol clusters running "on-premises" are usually protected by private networks, VPN connections, corporate Wi-fi, etc. TLS does not add any meaningful security in this case.
- Exasol SAAS clusters running in the cloud are accessible using public internet and are genuinely at risk of MITM attacks. TLS with full certificate validation is required.

If you want to set custom TLS encryption settings, please check the examples below.

### Certification verification

- Exasol running "on-premises" uses self-signed SSL certificate by default. You may generate a proper SSL certificate and upload it using [instruction](https://docs.exasol.com/administration/on-premise/access_management/tls_certificate.htm).
- Exasol Docker uses self-signed SSL certificate by default. You may generate a proper SSL certificate and use it via editing of EXAConf file. More details are available on the [GitHub page](https://github.com/exasol/docker-db).
- Exasol SAAS running in the cloud uses proper certificate generated by public certificate authority. It does not require any extra setup.

Certificate verification is disabled by default for connections with username and password.  Certificate verification is enabled by default for connections with username and OpenID token.

Similar to JDBC / ODBC drivers, PyEXASOL supports fingerprint certificate verification. Please check the examples below.

### Specific examples

1) How to connect with TLS encryption:

```python
pyexasol.connect(dsn='myexasol:8563'
                 , user='user'
                 , password='password'
                 , encryption=True)
```

2) How to connect with TLS encryption and fingerprint verification:

```python
pyexasol.connect(dsn='myexasol/135a1d2dce102de866f58267521f4232153545a075dc85f8f7596f57e588a181:8563'
                 , user='user'
                 , password='password'
                 , encryption=True
                 )
```

3) How to connect with TLS encryption and full certificate verification "on-premises" using internal root CA (certificate authority):

```python
pyexasol.connect(dsn='myexasol:8563'
                 , user='user'
                 , password='password'
                 , encryption=True
                 , websocket_sslopt={
                    "cert_reqs": ssl.CERT_REQUIRED,
                    "ca_certs": '/path/to/rootCA.crt',
                 })
```

4) How to connect to Exasol SAAS (TLS encryption is REQUIRED for SAAS):

```python
pyexasol.connect(dsn='abc.cloud.exasol.com:8563'
                 , user='user'
                 , refresh_token='token'
                 , encryption=True
                 )
```

### "SERVER_HOSTNAME" verification problem

Previous versions of PyEXASOL were resolving all hostnames from connection string into unique IP addresses, and connection attempts to each individual node were performed using IP address. It was a problem for "hostname" verification of SSL certificates when full verification was enabled.

It is no longer a problem in the most recent PyEXASOL versions. PyEXASOL now remembers hostname for each IP address and sets `sslopt` option `server_hostname` properly for each connection attempt. You may safely remove it from `websocket_sslopt` if you had to use it previously.
